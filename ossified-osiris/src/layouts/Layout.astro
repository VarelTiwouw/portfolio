---
import "../styles/global.css";
---

<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<link rel="icon" href="/favicon.ico" />
		<meta name="generator" content={Astro.generator} />
		<title>Varel Tiwouw — Creative Developer</title>
		<meta name="description" content="Portfolio of Varel Tiwouw — designing and building editorial-grade interfaces, type-driven layouts, and precise digital experiences." />

		<!-- Google Fonts: Inter, JetBrains Mono -->
		<link rel="preconnect" href="https://fonts.googleapis.com" />
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
		<link
			href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@300;400;500;600&display=swap"
			rel="stylesheet"
		/>


	</head>
	<body class="bg-void text-paper font-sans">
		<slot />

		<script>
			import Lenis from 'lenis';

			// ═══════════════════════════════════════════════════════════
			// 1. THEME INITIALISATION
			// ═══════════════════════════════════════════════════════════
			(function () {
				const stored = localStorage.getItem("theme");
				const prefersDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
				const theme = stored || (prefersDark ? "dark" : "light");
				document.documentElement.dataset.theme = theme;
			})();

			window.__toggleTheme = () => {
				const current = document.documentElement.dataset.theme || "dark";
				const next = current === "dark" ? "light" : "dark";
				document.documentElement.dataset.theme = next;
				localStorage.setItem("theme", next);
			};

			// Attach event listener to theme button
			document.addEventListener('DOMContentLoaded', () => {
				const themeBtn = document.querySelector('button[onclick*="toggleTheme"]');
				if (themeBtn) {
					themeBtn.removeAttribute('onclick'); // Remove inline handler
					themeBtn.addEventListener('click', window.__toggleTheme);
				}
			});

			// ═══════════════════════════════════════════════════════════
			// 2. LENIS SMOOTH SCROLL
			// ═══════════════════════════════════════════════════════════
			let lenis = null;
			try {
				lenis = new Lenis({
					duration: 1.2,
					easing: (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t)),
					orientation: 'vertical',
					smoothWheel: true,
				});
				document.documentElement.classList.add('lenis');

				function raf(time) {
					lenis.raf(time);
					requestAnimationFrame(raf);
				}
				requestAnimationFrame(raf);
			} catch (e) {
				console.warn('Lenis init failed, falling back to native scroll:', e);
			}

			// ═══════════════════════════════════════════════════════════
		// 3. SECTION REVEAL ANIMATIONS (with exit support)
		// ═══════════════════════════════════════════════════════════
		try {
			const revealObserver = new IntersectionObserver(
				(entries) => {
					entries.forEach((entry) => {
						const el = entry.target;
						// Skip Hero from exit animations (always stays visible once shown)
						const isHero = el.id === 'top';

						if (entry.isIntersecting) {
							el.classList.remove("is-exiting");
							el.classList.add("is-visible");
						} else if (el.classList.contains("is-visible") && !isHero) {
							// Element has been previously visible, now exiting viewport
							el.classList.remove("is-visible");
							el.classList.add("is-exiting");
						}
					});
				},
				{ threshold: 0.05, rootMargin: "60px 0px -30px 0px" }
			);

			document.querySelectorAll(".reveal, [data-animate='section']").forEach((el) => {
				if (el.hasAttribute("data-animate")) {
					el.classList.add("fade-section");
				}
				el.querySelectorAll(".reveal-child, .reveal-hero").forEach((child, i) => {
					if (!child.style.getPropertyValue("--delay")) {
						child.style.setProperty("--delay", `${i * 120}ms`);
					}
				});
				revealObserver.observe(el);
			});

			// Hero: trigger after preloader finishes
			const heroSection = document.querySelector("#top");
			if (heroSection) {
				heroSection.classList.add("reveal");
				setTimeout(() => heroSection.classList.add("is-visible"), 2000);
			}

			// ── Clip-path reveal observer ──
			const clipObserver = new IntersectionObserver(
				(entries) => {
					entries.forEach((entry) => {
						const el = entry.target;
						if (entry.isIntersecting) {
							el.classList.remove("is-exiting");
							el.classList.add("is-visible");
						} else if (el.classList.contains("is-visible")) {
							el.classList.remove("is-visible");
							el.classList.add("is-exiting");
						}
					});
				},
				{ threshold: 0.15, rootMargin: "0px" }
			);

			document.querySelectorAll(".clip-circle, .clip-wipe, .clip-diagonal, .img-reveal, .wave-card").forEach((el) => {
				clipObserver.observe(el);
			});

		} catch (e) {
			console.warn('Reveal animations failed:', e);
			// Fallback: make everything visible immediately
			document.querySelectorAll('.reveal, .reveal-child, .reveal-hero, .clip-circle, .clip-wipe, .clip-diagonal, .img-reveal, .wave-card').forEach(el => {
				el.style.opacity = '1';
				el.style.transform = 'none';
				el.style.clipPath = 'none';
			});
		}

		// ═══════════════════════════════════════════════════════════
		// 3b. TEXT ANIMATIONS
		// ═══════════════════════════════════════════════════════════
		(function () {
			try {
				// ── Split Text (per character) ──
				document.querySelectorAll('[data-split-text]').forEach(el => {
					const text = el.textContent;
					el.innerHTML = '';
					let charIndex = 0;

					for (let i = 0; i < text.length; i++) {
						const char = text[i];
						const span = document.createElement('span');
						span.className = 'split-char' + (char === ' ' ? ' is-space' : '');
						span.textContent = char === ' ' ? '\u00A0' : char;
						span.style.setProperty('--char-delay', `${charIndex * 30}ms`);
						el.appendChild(span);
						if (char !== ' ') charIndex++;
					}
				});

				// ── Word-by-Word Reveal ──
				document.querySelectorAll('[data-word-reveal]').forEach(el => {
					const text = el.textContent.trim();
					const words = text.split(/\s+/);
					el.innerHTML = '';

					words.forEach((word, i) => {
						const wrap = document.createElement('span');
						wrap.className = 'word-wrap';

						const inner = document.createElement('span');
						inner.className = 'word-inner';
						inner.textContent = word;
						inner.style.setProperty('--word-delay', `${i * 80}ms`);

						wrap.appendChild(inner);
						el.appendChild(wrap);

						// Add space between words (except after last)
						if (i < words.length - 1) {
							el.appendChild(document.createTextNode(' '));
						}
					});
				});

				// ── Typewriter Effect ──
				document.querySelectorAll('[data-typewriter]').forEach(el => {
					const text = el.textContent.trim();
					const baseDelay = parseInt(el.dataset.typewriterDelay || '0', 10);
					el.innerHTML = '';

					// Create character spans
					const chars = [];
					for (let i = 0; i < text.length; i++) {
						const span = document.createElement('span');
						span.className = 'typewriter-char';
						span.textContent = text[i] === ' ' ? '\u00A0' : text[i];
						el.appendChild(span);
						chars.push(span);
					}

					// Add blinking cursor
					const cursor = document.createElement('span');
					cursor.className = 'typewriter-cursor';
					el.appendChild(cursor);

					// Store data for the observer
					el._twChars = chars;
					el._twBaseDelay = baseDelay;
					el._twCursor = cursor;
					el._twTyped = false;
				});

				// Typewriter IntersectionObserver
				const twObserver = new IntersectionObserver(
					(entries) => {
						entries.forEach((entry) => {
							const el = entry.target;
							if (entry.isIntersecting && !el._twTyped) {
								el._twTyped = true;
								const chars = el._twChars;
								const base = el._twBaseDelay;
								const cursor = el._twCursor;

								chars.forEach((ch, i) => {
									setTimeout(() => {
										ch.classList.add('is-typed');
									}, base + i * 35);
								});

								// Hide cursor after typing completes
								setTimeout(() => {
									cursor.style.opacity = '0';
								}, base + chars.length * 35 + 600);
							}
						});
					},
					{ threshold: 0.3 }
				);

				document.querySelectorAll('[data-typewriter]').forEach(el => {
					twObserver.observe(el);
				});

			} catch (e) {
				console.warn('Text animations failed:', e);
			}
		})();

			// ═══════════════════════════════════════════════════════════
			// 4. CUSTOM CURSOR
			// ═══════════════════════════════════════════════════════════
			(function () {
				try {
					const dot = document.getElementById("cursor-dot");
					const ring = document.getElementById("cursor-ring");
					if (!dot || !ring) return;

					// Check if touch device
					if ('ontouchstart' in window) return;

					let mouseX = 0, mouseY = 0;
					let ringX = 0, ringY = 0;
					let dotX = 0, dotY = 0;

					document.addEventListener("mousemove", (e) => {
						mouseX = e.clientX;
						mouseY = e.clientY;
					});

					// Smooth animation loop
					function animateCursor() {
						// Lerp for ring
						ringX += (mouseX - ringX) * 0.15;
						ringY += (mouseY - ringY) * 0.15;
						
						// Direct follow for dot (with slight lerp for smoothness)
						dotX += (mouseX - dotX) * 0.5;
						dotY += (mouseY - dotY) * 0.5;

						// Use transform for performance (composite layer)
						if (dot) dot.style.transform = `translate3d(${dotX}px, ${dotY}px, 0) translate(-50%, -50%)`;
						if (ring) ring.style.transform = `translate3d(${ringX}px, ${ringY}px, 0) translate(-50%, -50%)`;

						requestAnimationFrame(animateCursor);
					}
					animateCursor();

					// Hover detection
					const hoverTargets = "a, button, [data-hover], input, textarea, .glass-container";
					document.addEventListener("mouseover", (e) => {
						if (e.target.closest(hoverTargets)) {
							dot.classList.add("is-hovering");
							ring.classList.add("is-hovering");
						}

						// Check for hidden cursor zones
						if (e.target.closest('[data-cursor-hidden="true"]')) {
							dot.classList.add("is-hidden");
							ring.classList.add("is-hidden");
						} else {
							dot.classList.remove("is-hidden");
							ring.classList.remove("is-hidden");
						}
					});
					document.addEventListener("mouseout", (e) => {
						if (e.target.closest(hoverTargets)) {
							dot.classList.remove("is-hovering");
							ring.classList.remove("is-hovering");
						}
					});
				} catch (e) {
					console.warn('Custom cursor failed:', e);
				}
			})();

			// ═══════════════════════════════════════════════════════════
			// 5. CURSOR GLOW TRAIL (DISABLED FOR PERFORMANCE)
			// ═══════════════════════════════════════════════════════════
			/*
			(function () {
				try {
					const canvas = document.getElementById("cursor-glow");
					if (!canvas || 'ontouchstart' in window) return;

					const ctx = canvas.getContext("2d");
					let width = window.innerWidth;
					let height = window.innerHeight;
					canvas.width = width;
					canvas.height = height;

					window.addEventListener("resize", () => {
						width = window.innerWidth;
						height = window.innerHeight;
						canvas.width = width;
						canvas.height = height;
					});

					const trail = [];
					const maxTrail = 20;
					let mouseX = 0, mouseY = 0;

					document.addEventListener("mousemove", (e) => {
						mouseX = e.clientX;
						mouseY = e.clientY;
					});

					function drawTrail() {
						ctx.clearRect(0, 0, width, height);

						trail.push({ x: mouseX, y: mouseY, life: 1.0 });
						if (trail.length > maxTrail) trail.shift();

						for (let i = 0; i < trail.length; i++) {
							const p = trail[i];
							p.life -= 0.04;
							if (p.life <= 0) continue;

							const alpha = p.life * 0.15;
							const radius = p.life * 60;

							const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, radius);
							gradient.addColorStop(0, `rgba(200, 40, 0, ${alpha})`);
							gradient.addColorStop(1, "rgba(200, 40, 0, 0)");

							ctx.beginPath();
							ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
							ctx.fillStyle = gradient;
							ctx.fill();
						}

						// Clean dead particles
						for (let i = trail.length - 1; i >= 0; i--) {
							if (trail[i].life <= 0) trail.splice(i, 1);
						}

						requestAnimationFrame(drawTrail);
					}
					drawTrail();
				} catch (e) {
					console.warn('Cursor glow trail failed:', e);
				}
			})();
			*/

			// ═══════════════════════════════════════════════════════════
			// 6. MAGNETIC BUTTONS
			// ═══════════════════════════════════════════════════════════
			(function () {
				try {
					if ('ontouchstart' in window) return;

					// Reverting optimization: Include theme toggle button again
					document.querySelectorAll(".magnetic, nav a, .glass-navbar button").forEach((el) => {
						el.addEventListener("mousemove", (e) => {
							const rect = el.getBoundingClientRect();
							const x = e.clientX - rect.left - rect.width / 2;
							const y = e.clientY - rect.top - rect.height / 2;
							el.style.transform = `translate(${x * 0.3}px, ${y * 0.3}px)`;
							el.style.transition = "transform 0s";
						});

						el.addEventListener("mouseleave", () => {
							el.style.transition = "transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94)";
							el.style.transform = "translate(0, 0)";
						});
					});
				} catch (e) {
					console.warn('Magnetic buttons failed:', e);
				}
			})();

			// ═══════════════════════════════════════════════════════════
			// 7. TEXT SCRAMBLE (Hero name)
			// ═══════════════════════════════════════════════════════════
			(function () {
				try {
					const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789@#$%&*";

					function scramble(el) {
						const originalText = el.dataset.text || el.textContent;
						el.dataset.text = originalText;
						const length = originalText.length;
						let iteration = 0;

						const interval = setInterval(() => {
							el.textContent = originalText
								.split("")
								.map((char, index) => {
									if (index < iteration) return originalText[index];
									return chars[Math.floor(Math.random() * chars.length)];
								})
								.join("");

							if (iteration >= length) clearInterval(interval);
							iteration += 1 / 2;
						}, 30);
					}

					// Wait for preloader to finish, then scramble
					setTimeout(() => {
						document.querySelectorAll("[data-scramble]").forEach((el) => {
							scramble(el);
						});
					}, 2100);
				} catch (e) {
					console.warn('Text scramble failed:', e);
				}
			})();

			// ═══════════════════════════════════════════════════════════
			// 8. PARALLAX PROJECT IMAGES
			// ═══════════════════════════════════════════════════════════
			(function () {
				try {
					const parallaxItems = document.querySelectorAll(".parallax-img");
					if (!parallaxItems.length) return;

					function updateParallax() {
						parallaxItems.forEach((img) => {
							const rect = img.getBoundingClientRect();
							const viewH = window.innerHeight;
							const center = rect.top + rect.height / 2;
							const offset = (center - viewH / 2) / viewH;
							img.style.transform = `translateY(${offset * -30}px) scale(1.08)`;
						});
					}

					window.addEventListener("scroll", () => {
						requestAnimationFrame(updateParallax);
					}, { passive: true });

					updateParallax();
				} catch (e) {
					console.warn('Parallax failed:', e);
				}
			})();

			// ═══════════════════════════════════════════════════════════
			// 9. PAGE TRANSITIONS (smooth section nav)
			// ═══════════════════════════════════════════════════════════
			(function () {
				try {
					const transitionEl = document.getElementById("page-transition");
					if (!transitionEl) return;

					document.querySelectorAll('a[href^="#"]').forEach((link) => {
						link.addEventListener("click", (e) => {
							const targetId = link.getAttribute("href");
							const target = document.querySelector(targetId);
							if (!target) return;

							e.preventDefault();

							transitionEl.classList.add("is-active");

							setTimeout(() => {
								if (lenis) {
									lenis.scrollTo(target, { offset: -80, immediate: false });
								} else {
									target.scrollIntoView({ behavior: 'smooth', block: 'start' });
								}
							}, 400);

							setTimeout(() => {
								transitionEl.classList.remove("is-active");
							}, 800);
						});
					});
				} catch (e) {
					console.warn('Page transitions failed:', e);
				}
			})();

			// ═══════════════════════════════════════════════════════════
			// 10. SCROLL-REACTIVE GRADIENT BLOBS (PARALLAX)
			// ═══════════════════════════════════════════════════════════
			(function () {
				try {
					const blobs = document.querySelectorAll('.gradient-blob');
					if (!blobs.length) return;

					// Each blob has unique parallax speeds & directions
					// speedY: how far it travels vertically (in vh) across full scroll
					// speedX: horizontal drift amplitude (in vw), oscillates with scroll
					// phase: offset for sine wave so blobs don't all move the same
					const blobConfigs = [
						{ speedY: -200, speedX: 70,  phase: 0,    scaleRange: 0.4  },
						{ speedY: -160, speedX: -60, phase: 1.2,  scaleRange: 0.3  },
						{ speedY: -220, speedX: 50,  phase: 2.5,  scaleRange: 0.35 },
						{ speedY: -140, speedX: -90, phase: 3.8,  scaleRange: 0.25 },
						{ speedY: -180, speedX: 80,  phase: 5.0,  scaleRange: 0.32 },
					];

					const morphStages = [
						'50% 50% 50% 50% / 50% 50% 50% 50%',
						'60% 40% 55% 45% / 45% 60% 40% 55%',
						'40% 60% 30% 70% / 65% 35% 60% 40%',
						'55% 45% 65% 35% / 35% 55% 45% 65%',
						'35% 65% 50% 50% / 55% 45% 55% 45%',
						'65% 35% 45% 55% / 45% 65% 35% 55%',
					];

					let ticking = false;

					function updateBlobs() {
						const scrollY = window.scrollY;
						const docHeight = document.documentElement.scrollHeight - window.innerHeight;
						const scrollPercent = docHeight > 0 ? scrollY / docHeight : 0;

						blobs.forEach((blob, i) => {
							const config = blobConfigs[i] || blobConfigs[0];

							// Vertical parallax: move from bottom to top as user scrolls
							const ty = config.speedY * scrollPercent;

							// Horizontal drift: sinusoidal oscillation for organic feel
							const tx = config.speedX * Math.sin(scrollPercent * Math.PI * 2 + config.phase);

							// Scale breathing
							const scale = 1 + config.scaleRange * (0.5 + 0.5 * Math.sin(scrollPercent * Math.PI * 3 + i));

							// Morph shape based on scroll
							const morphIndex = Math.floor((scrollPercent * (morphStages.length - 1) * 2) + i * 0.7) % morphStages.length;
							const morphRadius = morphStages[morphIndex];

							// Opacity pulses gently
							const opacity = 0.5 + 0.35 * Math.sin(scrollPercent * Math.PI * 2 + i * 1.5);

							blob.style.transform = `translate(${tx}vw, ${ty}vh) scale(${scale})`;
							blob.style.borderRadius = morphRadius;
							blob.style.opacity = opacity;
						});

						ticking = false;
					}

					window.addEventListener('scroll', () => {
						if (!ticking) {
							requestAnimationFrame(updateBlobs);
							ticking = true;
						}
					}, { passive: true });

					updateBlobs();
				} catch (e) {
					console.warn('Gradient blobs failed:', e);
				}
			})();

			// ═══════════════════════════════════════════════════════════
			// 11. 3D TILT CARDS
			// ═══════════════════════════════════════════════════════════
			(function () {
				try {
					if ('ontouchstart' in window) return;

					document.querySelectorAll('[data-tilt]').forEach(card => {
						// Add transition style for smooth reset
						card.style.transition = "transform 0.1s ease-out"; 

						// Add glare element dynamically
						let glare = card.querySelector('.tilt-glare');
						if (!glare) {
							glare = document.createElement('div');
							glare.className = 'tilt-glare';
							glare.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:10;background:radial-gradient(circle at 50% 50%, rgba(255,255,255,0.15), transparent 80%);opacity:0;transition:opacity 0.3s;mix-blend-mode:overlay;border-radius:inherit;';
							card.appendChild(glare);
						}

						card.addEventListener('mousemove', (e) => {
							const rect = card.getBoundingClientRect();
							const x = e.clientX - rect.left;
							const y = e.clientY - rect.top;
							const centerX = rect.width / 2;
							const centerY = rect.height / 2;
							
							// Rotation max 10deg
							const rotateX = ((y - centerY) / centerY) * -8; 
							const rotateY = ((x - centerX) / centerX) * 8;

							// Glare position
							const glareX = (x / rect.width) * 100;
							const glareY = (y / rect.height) * 100;

							card.style.transition = "transform 0.05s linear"; // Faster response on move
							card.style.transform = `perspective(1000px) rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale3d(1.02, 1.02, 1.02)`;
							
							if (glare) {
								glare.style.background = `radial-gradient(circle at ${glareX}% ${glareY}%, rgba(255,255,255,0.3), transparent 60%)`;
								glare.style.opacity = '1';
							}
						});

						card.addEventListener('mouseleave', () => {
							card.style.transition = "transform 0.4s cubic-bezier(0.23, 1, 0.32, 1)"; // Smooth reset
							card.style.transform = 'perspective(1000px) rotateX(0) rotateY(0) scale3d(1, 1, 1)';
							if (glare) glare.style.opacity = '0';
						});
					});
				} catch (e) {
					console.warn('3D Tilt failed:', e);
				}
			})();
		</script>
	</body>
</html>
